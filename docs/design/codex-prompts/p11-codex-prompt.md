# P11 Implementation Prompt for GPT-5.2-Codex

You are **GPT-5.2-Codex**. Your job is to implement **P11 QA review** plus the **P10 Tier-2 Auto-Diagnose** escalation and the associated **CLAUDE.md contract updates**, exactly as specified below.

Work in: `/tank/dump/DEV/deadfish-cli`.

## Scope (Hard-Bounded)

You MUST change **exactly 4 files**:
1. Create: `.pipe/p11/P11_QA_REVIEW.md`
2. Create: `.pipe/p10/P10_AUTO_DIAGNOSE.md`
3. Update: `CLAUDE.md`
4. Update: `PROMPT_OPTIMIZATION.md`

Do **NOT** modify any other files (no scripts, no parsers, no pipeline code).

## Inputs You MUST Read (in this repo)

Read these files before editing:
- `.pipe/p11/synthesis-opus-orchestrator.md` (APPROVED synthesis v2; follow exactly)
- `.pipe/p11/synthesis-review-gpt52-r2.md` (R2 review; incorporate the 3 minor fixes)
- `.pipe/p10/P10_FORMAT_REPAIR.md` (style reference + existing P10 contract)
- `.pipe/p9/P9_VERIFY_CRITERION.md` (style reference)
- `CLAUDE.md` (binding contract; match voice and structure)
- `PROMPT_OPTIMIZATION.md` (status table; update P11 row)

## Goal

Add a **track-level QA review gate (P11)** that runs after the last task‚Äôs `reflect`, before track completion.
Add **P10 Tier-2 Auto-Diagnose** to create a deterministic 3-tier escalation policy:
Tier 1 = format-repair; Tier 2 = auto-diagnose; Tier 3 = per-block failure policy.

You are updating docs/templates only. Do not implement orchestrator logic or parsers in code in this change.

## Non-Negotiables (Locked)

- P11 outputs exactly one fixed-shape `QA_REVIEW` sentinel block (no prose outside).
- P11 is **track-level** (holistic), not per-task (per-task triggers are opt-in only via POLICY).
- QA review has **bounded remediation**: max 1 remediation task; if remediation already attempted, accept with warnings and complete the track.
- Smart-skip is deterministic (no LLM) and happens in `reflect` Part A at track-end.
- R2 fix #1: remediation counter updates must be written sequentially using `old_total = ...; track.task_total = old_total + 1; track.task_current = old_total + 1`.
- R2 fix #2: remove ‚Äúno timeout‚Äù wording; budgets are enforced by orchestrator/budget policy, and the prompt has **no internal timeout concept**.
- R2 fix #3: never set `C*=FAIL` unless there exists ‚â•1 FINDINGS item in that category with severity ‚â• MAJOR.

---

# Deliverable 1 ‚Äî Create `.pipe/p11/P11_QA_REVIEW.md` (Track-Level QA Review Template)

Create the file using the same template style as `.pipe/p9/P9_VERIFY_CRITERION.md` and `.pipe/p10/P10_FORMAT_REPAIR.md` (plain-text sections, strict rules, placeholder-driven).

Use the **FINAL TEMPLATE** from `.pipe/p11/synthesis-opus-orchestrator.md` ‚Üí Part A ‚Üí Section 3, with exactly one modification from R2 finding #3:
- Add an explicit grammar rule: **`C*=FAIL` requires ‚â•1 FINDINGS item with `category=C*` and `severity ‚àà {MAJOR, CRITICAL}`.**

## `.pipe/p11/P11_QA_REVIEW.md` content (verbatim except placeholders)

IDENTITY
You are the QA reviewer for the deadf(ish) pipeline.
You review a completed track holistically ‚Äî not individual tasks.
You enforce scope discipline, living docs conventions, cross-task consistency, architectural coherence, safety, and track completeness.
Output ONLY the review block ‚Äî no other text.

TRACK CONTEXT
Track: {track_id} ‚Äî {track_name}
Goal: {track_goal} (from SPEC.md)
Tasks completed: {task_count}
Total diff lines: {total_diff_lines}
Plan expected files: {plan_expected_files}
Task summaries (‚â§150 tokens each):
{task_summaries_list}

LIVING DOCS (current)
{living_docs_content}

COMBINED DIFF (track-level, {plan_base_commit}..HEAD)
{combined_git_diff_stat}

KEY DIFF HUNKS (sampled across tasks, ~8K tokens max)
{sampled_diff_hunks}

SPEC.md (track requirements)
{spec_content}

REVIEW RUBRIC (6 categories ‚Äî VERDICT=FAIL if any category=FAIL with severity ‚â• MAJOR)

C0 ‚Äî SCOPE SANITY
Compare modified files against plan expected files. Flag unplanned subsystem edits, sweeping refactors, unrelated dependency changes.
Score: PASS if all changes are in-scope or strictly mechanical (formatting, autogenerated). FAIL if unplanned high-impact edits.

C1 ‚Äî LIVING DOCS COMPLIANCE
For each convention in PATTERNS.md: is the code consistent?
For each gotcha in PITFALLS.md: was it avoided?
For workflow rules in WORKFLOW.md: were they followed?
For deps in TECH_STACK.md: are they used correctly?
Score: PASS if ‚â§2 MINOR deviations. FAIL if any MAJOR+ deviation.

C2 ‚Äî CROSS-TASK CONSISTENCY
Scan all changed files across all track tasks for naming, error handling, test patterns, imports.
Score: PASS if patterns are uniform. FAIL if ‚â•3 inconsistencies or any MAJOR inconsistency.

C3 ‚Äî ARCHITECTURAL COHERENCE
Check for circular dependencies, dead/orphaned code, clean API surface, sensible wiring.
Verify critical entrypoints ‚Üí handlers ‚Üí core logic ‚Üí I/O are connected.
Score: PASS if no structural issues. FAIL if circular deps, orphaned features, or broken wiring.

C4 ‚Äî TRACK COMPLETENESS
Does the combined work deliver the track goal from SPEC.md?
Are dangling TODOs acceptable (scope-limited) or blocking?
Score: PASS if goal met and no blocking TODOs. FAIL if track goal not achieved.

C5 ‚Äî SAFETY/CORRECTNESS
High-risk patterns only: authorization bypass, data loss, injection vectors, unsafe parsing, misuse of dangerous APIs.
Do NOT fail for style or preference ‚Äî only for genuine correctness/safety concerns.
Score: PASS if no high-risk issues. FAIL if any safety/correctness issue found.

SEVERITY RULES
- MINOR: style/naming preference not matching docs (non-blocking)
- MAJOR: pattern violation, missing wiring, inconsistent behavior across tasks
- CRITICAL: circular dep, safety issue, track goal not met, data loss risk

OUTPUT FORMAT (exactly one block, no prose outside)
Block shape is FIXED ‚Äî always include all sections, even if empty.

<<<QA_REVIEW:V1:NONCE={nonce}>>>
VERDICT=PASS|FAIL
RISK=LOW|MEDIUM|HIGH
C0=PASS|FAIL
C1=PASS|FAIL
C2=PASS|FAIL
C3=PASS|FAIL
C4=PASS|FAIL
C5=PASS|FAIL
FINDINGS_COUNT={N}
FINDINGS:
- severity=CRITICAL|MAJOR|MINOR category=C0|C1|C2|C3|C4|C5 file="path" issue="description"
REMEDIATION_COUNT={N}
REMEDIATION:
- file="path" action="what to fix"
NOTES="Brief summary of track quality. ‚â§500 chars."
<<<END_QA_REVIEW:NONCE={nonce}>>>

GRAMMAR RULES (strict)
- Exactly one opener: <<<QA_REVIEW:V1:NONCE={nonce}>>>
- Exactly one closer: <<<END_QA_REVIEW:NONCE={nonce}>>>
- Nonce: ^[0-9A-F]{6}$
- No blank lines inside block. No tabs. No prose outside block.
- VERDICT: exactly PASS or FAIL (unquoted)
- RISK: exactly LOW, MEDIUM, or HIGH (unquoted)
- C0-C5: exactly PASS or FAIL (unquoted)
- FINDINGS_COUNT: integer ‚â• 0. Must equal actual number of FINDINGS items.
- FINDINGS: section always present. If FINDINGS_COUNT=0, section header present but no items.
  Required if VERDICT=FAIL: FINDINGS_COUNT ‚â• 1.
  Each item: severity, category, file, issue (all required, in this order). issue is quoted, single-line, no internal double quotes.
  R2 RULE: Never set C*=FAIL unless there exists ‚â•1 FINDINGS item with category=C* and severity=MAJOR|CRITICAL.
- REMEDIATION_COUNT: integer ‚â• 0. Must equal actual number of REMEDIATION items.
- REMEDIATION: section always present. If REMEDIATION_COUNT=0, section header present but no items.
  Required if VERDICT=FAIL: REMEDIATION_COUNT ‚â• 1.
  Each item: file, action (both required, in this order). action is quoted, single-line, no internal double quotes.
- NOTES: quoted string, ‚â§500 chars, no internal double quotes. Use single quotes or backticks inside.
- Field order is fixed: VERDICT, RISK, C0-C5, FINDINGS_COUNT, FINDINGS, REMEDIATION_COUNT, REMEDIATION, NOTES.

---

# Deliverable 2 ‚Äî Create `.pipe/p10/P10_AUTO_DIAGNOSE.md` (Tier 2 Diagnostic Prompt)

Create the file using the **AUTO-DIAGNOSE PROMPT** from `.pipe/p11/synthesis-opus-orchestrator.md` ‚Üí Part B, with exactly one modification from R2 finding #2:
- Replace ‚Äúno timeout‚Äù concept with a note that the **orchestrator enforces budget**, and the prompt itself has **no internal timeout concept**.

## `.pipe/p10/P10_AUTO_DIAGNOSE.md` content (verbatim except placeholders)

IDENTITY
You are a diagnostic agent for the deadf(ish) pipeline.
A format-repair retry has failed. Determine WHY and attempt to FIX the output.
You do NOT modify source code. You either fix the LLM output or report the structural mismatch.

SITUATION
Block type: {BLOCK_TYPE}
Nonce: {NONCE}
Original parse error: {ORIGINAL_PARSER_ERROR}
Retry parse error: {RETRY_PARSER_ERROR}

ORIGINAL OUTPUT (may be truncated)
{ORIGINAL_OUTPUT}

REPAIR ATTEMPT OUTPUT
{RETRY_OUTPUT}

FORMAT CONTRACT (what the stage prompt specified)
{FORMAT_CONTRACT}

PARSER VALIDATION LOGIC (relevant regex/function only)
{PARSER_EXCERPT}

YOUR TASK
1. Compare the format contract against the parser validation logic.
2. If they match: the LLM output is broken. Manually reconstruct the correct block from the content.
3. If they don't match: report the structural mismatch (contract says X, parser expects Y).

OUTPUT (choose exactly one):

Option A ‚Äî Fixed output (you reconstructed a valid block):
<<<DIAGNOSTIC:V1:FIXED>>>
{corrected sentinel block that satisfies the parser}
<<<END_DIAGNOSTIC:FIXED>>>

Option B ‚Äî Structural mismatch (output cannot satisfy current parser):
<<<DIAGNOSTIC:V1:MISMATCH>>>
COMPONENT=PARSER|PROMPT|BOTH
EXPLANATION="What's wrong and why the output cannot satisfy the current parser."
SUGGESTED_FIX="Specific change needed to resolve the mismatch."
<<<END_DIAGNOSTIC:MISMATCH>>>

RULES
- Output exactly one DIAGNOSTIC block. No prose outside.
- For Option A: the block inside FIXED must pass the parser as-is.
- For Option B: EXPLANATION and SUGGESTED_FIX are quoted, single-line, ‚â§500 chars each.
- Do not modify any source code files. Your output is diagnostic only.
- This prompt has no internal timeout concept. The orchestrator enforces budgets and call limits.

---

# Deliverable 3 ‚Äî Update `CLAUDE.md` (Contract Additions + Replacements)

Update `CLAUDE.md` to add the P11 QA review integration, the P10 3-tier escalation policy, and QA_REVIEW sentinel grammar documentation.

Match CLAUDE.md‚Äôs existing voice: terse, contract-like, deterministic. All state transitions must be explicit.

## 3a) DECIDE table entry 13.5 (qa_review action)

Placement: in `### Step 3: DECIDE` table, insert this row **between** row 13 (`reflect`) and row 14 (`summarize`):

| 13.5 | `execute` | `task.sub_step: qa_review` | `qa_review` |

## 3b) P11 QA review action spec (full, explicit) + state transitions

Add a new action spec section:

Placement: under `## Action Specifications`, add this new section **immediately after** the existing `### \`reflect\` (execute phase)` section, before `retry_task`.

### `qa_review` (execute phase)

Purpose: Track-level holistic QA review runs after the last task‚Äôs reflect and before track completion.

Inputs:
- `STATE.yaml`
- Track `SPEC.md`
- Track `PLAN.md`
- All `TASK_{NNN}.md` files for the track
- Living docs under `.deadf/docs/` (if present)
- Git history/diff from `track.plan_base_commit..HEAD`
- Template: `.pipe/p11/P11_QA_REVIEW.md`

Evidence bundle (hard caps):
- `combined_git_diff_stat`: `git diff {track.plan_base_commit}..HEAD --stat`
- `sampled_diff_hunks`: `git diff {track.plan_base_commit}..HEAD` capped to ~8K tokens
- `task_summaries_list`: ‚â§150 tokens per task; ‚â§750 tokens total for first 5 tasks
- `living_docs_content`: `.deadf/docs/` (all present docs; use existing P9.5 per-doc token budgets)
- `spec_content`: `SPEC.md`
- `plan_expected_files`: FILES entries from `PLAN.md`
- Total evidence budget: ‚â§15K tokens

Execution:
1. Dispatch to GPT-5.2 using `.pipe/p11/P11_QA_REVIEW.md`.
2. Parse exactly one `QA_REVIEW` sentinel block:
   a. Exactly one opener/closer with matching nonce
   b. `FINDINGS_COUNT` matches number of FINDINGS items
   c. `REMEDIATION_COUNT` matches number of REMEDIATION items
   d. Fixed field order; no extra keys; no blank lines; no tabs
3. On parse failure:
   - Tier 1: run `.pipe/p10/P10_FORMAT_REPAIR.md` one retry (same nonce)
   - If Tier 1 still fails: follow the P10 3-tier escalation policy (Tier 2 auto-diagnose; then Tier 3 per-block policy)

State transitions (explicit):

On PASS:
```yaml
track.status: complete
phase: select-track
task.sub_step: null
```

On FAIL (first time; remediation not yet attempted):
```text
old_total = track.task_total
track.task_total = old_total + 1
track.task_current = old_total + 1
task.sub_step = generate
task.retry_count = 0
track.qa_remediation = true
```

On FAIL (remediation already attempted; `track.qa_remediation == true`):
```yaml
track.status: complete
phase: select-track
task.sub_step: null
```

Additional behavior:
- On FAIL with `RISK=HIGH`: request a second opinion from Opus on the top 1‚Äì3 CRITICAL/HIGH findings + relevant diff hunks + relevant living doc rules.
- C5 CRITICAL arbitration rule: cannot override to PASS unless the second opinion explicitly states the finding is incorrect and references a specific safeguard in the diff/code.
- If FAIL is confirmed: generate exactly one remediation task and proceed (bounded remediation).
- If remediation already happened: accept with warnings and log findings to `.deadf/logs/qa_warnings.md` (append-only).

## 3c) Smart-skip gate logic in `reflect` Part A (track-end gating)

Update the existing `### \`reflect\` (execute phase)` ‚Üí Part A (‚ÄúState Advance‚Äù) track-end behavior.

Placement: in `reflect` Part A, replace the existing ‚ÄúAdvance to next task or track‚Äù block with the exact text below.

Exact replacement text to paste into `CLAUDE.md`:

4. Advance to next task or track:
   - If more tasks in track: `task.sub_step: generate`, increment `task_current`
   - If track complete (`task_current == task_total`):
     - Run smart-skip gate (deterministic; no LLM):
       ```
       skip_qa = (
         POLICY.qa_review.enabled == false
         OR track.task_total == 1 AND POLICY.qa_review.skip_single_task_tracks == true
         OR total_diff_lines < POLICY.qa_review.skip_trivial_diffs
         OR .deadf/docs/ is empty AND POLICY.qa_review.skip_empty_docs == true
       )
       ```
     - If `skip_qa`:
       - `track.status: complete`, move to `tracks_completed`, set `phase: select-track`
     - Else:
       - `task.sub_step: qa_review`
       - DO NOT set `track.status: complete` yet
   - If all tracks done: `phase: complete`

## 3d) QA_REVIEW sentinel grammar (fixed-shape block)

Placement: in `## Sentinel Parsing`, add a new subsection after ‚ÄúVerdict Block Format‚Äù:

### QA_REVIEW Block Format

```
<<<QA_REVIEW:V1:NONCE={nonce}>>>
VERDICT=PASS|FAIL
RISK=LOW|MEDIUM|HIGH
C0=PASS|FAIL
C1=PASS|FAIL
C2=PASS|FAIL
C3=PASS|FAIL
C4=PASS|FAIL
C5=PASS|FAIL
FINDINGS_COUNT={N}
FINDINGS:
- severity=CRITICAL|MAJOR|MINOR category=C0|C1|C2|C3|C4|C5 file="path" issue="description"
REMEDIATION_COUNT={N}
REMEDIATION:
- file="path" action="what to fix"
NOTES="Brief summary of track quality. ‚â§500 chars."
<<<END_QA_REVIEW:NONCE={nonce}>>>
```

QA_REVIEW block rules (parser-safe):
- Fixed shape: FINDINGS and REMEDIATION sections are always present.
- Field order is fixed (same as `.pipe/p11/P11_QA_REVIEW.md`).
- No blank lines inside block; no tabs; no prose outside.
- `FINDINGS_COUNT` and `REMEDIATION_COUNT` must equal the actual number of items.
- If `VERDICT=FAIL`: `FINDINGS_COUNT >= 1` and `REMEDIATION_COUNT >= 1`.
- R2 RULE: Never set `C*=FAIL` unless there exists ‚â•1 FINDINGS item with `category=C*` and `severity=MAJOR|CRITICAL`.

## 3e) P10 3-tier escalation policy (replace current 2-tier)

In `## Sentinel Parsing`, replace the existing `### P10: Format-Repair (Universal; One Retry Max)` section with a 3-tier policy that:
- Keeps Tier 1 exactly as-is (format-repair, one retry, same nonce).
- Adds Tier 2 Auto-Diagnose referencing `.pipe/p10/P10_AUTO_DIAGNOSE.md`.
- Adds Tier 3 Human Escalation / per-block failure policy.
- Includes the per-block table from synthesis v2 Part B (‚ÄúPer-Block Tier Behavior‚Äù), adapted into CLAUDE.md voice.
- Includes the ‚Äúno internal timeout concept; orchestrator enforces budget‚Äù note for Tier 2.

Exact replacement text to paste into `CLAUDE.md` (replace the entire existing P10 section under `## Sentinel Parsing`):

### P10: 3-Tier Escalation (Sentinel Parse/Validation Failures)

When a sentinel block fails parsing/validation, the orchestrator follows a deterministic 3-tier policy:
1. Tier 1: format-repair once
2. Tier 2: auto-diagnose once (either FIXED output or MISMATCH report)
3. Tier 3: per-block failure policy

Tier 1 and Tier 2 are bounded to one attempt each. No loops.

#### Tier 1 ‚Äî Format Repair (Universal; One Retry Max)

- Template: `.pipe/p10/P10_FORMAT_REPAIR.md`
- Inputs: verbatim parser/validator error + verbatim original output + injected per-block format contract
- Constraints: same nonce (same cycle), same model, one retry maximum
- Output: block-only corrected sentinel block (no prose, no code fences)

Guards (skip Tier 1):
- If original output is `< 50 chars`: skip Tier 1; follow Tier 3 per-block policy.
- If the error contains a Python traceback/crash: skip Tier 1; follow Tier 3 per-block policy (tooling bug).

Truncation:
- If original output is > 8K chars: include first 4K + last 4K with `"[...truncated...]"`.

#### Tier 2 ‚Äî Auto-Diagnose (Output Fix OR Structural Mismatch)

Trigger: Tier 1 fails.

- Template: `.pipe/p10/P10_AUTO_DIAGNOSE.md`
- Actor: GPT-5.2-high via Codex MCP / `codex exec`
- Inputs: both parser errors, both outputs, authoritative format contract, and parser excerpt (relevant regex/function only)
- Output (exactly one):
  - `<<<DIAGNOSTIC:V1:FIXED>>> ... <<<END_DIAGNOSTIC:FIXED>>>` (contains a corrected sentinel block that must pass the parser as-is)
  - `<<<DIAGNOSTIC:V1:MISMATCH>>> ... <<<END_DIAGNOSTIC:MISMATCH>>>` (structured mismatch report)
- Role boundary: Tier 2 does NOT patch source code. It only fixes the output or diagnoses mismatch.
- Budget note: the prompt has no internal timeout concept; the orchestrator enforces budgets and call limits.

If Tier 2 returns FIXED:
- Parse the corrected sentinel block.
- If parsing still fails: proceed to Tier 3.

If Tier 2 returns MISMATCH:
- Queue tooling repair (see below).
- Proceed to Tier 3 for the current cycle.

#### Tier 3 ‚Äî Per-Block Failure Policy

| Block Type | Tier 1 | Tier 2 | Tier 3 |
|-----------|--------|--------|--------|
| PLAN / TRACK / SPEC | Format retry | Auto-diagnose | `CYCLE_FAIL` with diagnostic report |
| VERDICT (per-criterion) | Format retry | Auto-diagnose | That criterion ‚Üí `NEEDS_HUMAN` (continue other criteria) |
| REFLECT | Format retry | Non-fatal degrade (`ACTION=NOP`, log warning) | Never reaches Tier 3 |
| QA_REVIEW | Format retry | Auto-diagnose | Accept with warnings, log, complete track |

Tooling repair queue (Tier 2 MISMATCH):
1. Log the full diagnostic to `.deadf/logs/mismatch-{cycle_id}.md`
2. Follow Tier 3 policy for the current cycle
3. Queue a tooling-repair meta-task:
   - Path: `.deadf/tooling-repairs/repair-{timestamp}.md`
   - Contents: `COMPONENT`, `EXPLANATION`, `SUGGESTED_FIX`
4. Tooling-repairs are picked up at next `select-track` phase (before normal track selection) and implemented by `gpt-5.2-codex` via the normal implement‚Üíverify flow.

Parser mismatch warning:
- `extract_plan.py` does not match TRACK/SPEC/multi-task PLAN formats today. Do not invoke Tier 1/Tier 2 for those blocks until deterministic parsers exist for them.

## 3f) MISMATCH ‚Üí tooling repair queue mechanism

This is already included verbatim inside the P10 3-tier replacement text above (under ‚ÄúTooling repair queue (Tier 2 MISMATCH)‚Äù). Do not duplicate it elsewhere.

## 3g) POLICY.yaml qa_review section documentation

Add documentation for the `qa_review:` POLICY section (placement: near the smart-skip gate logic and/or near Sentinel Parsing):

```yaml
qa_review:
  enabled: true
  skip_single_task_tracks: true
  skip_trivial_diffs: 50
  skip_empty_docs: true
  max_remediation_tasks: 1
  severity_threshold: MAJOR
  second_opinion_on_high_risk: true
  task_triggers: []
```

Note: This is documentation only; you are not editing POLICY.yaml in this change.

---

# Deliverable 4 ‚Äî Update `PROMPT_OPTIMIZATION.md` (Mark P11 Implemented)

In the ‚ÄúReview order‚Äù table under ‚ÄúPhase 2: Per-Prompt Brainstorm (CURRENT)‚Äù, update row 10:
- `P11 ‚Äî QA Review` status from `üî≤` to `‚úÖ Implemented (commit: <TBD>)`

Use a placeholder commit string, do not invent a hash.

---

# Acceptance Checklist (for your own verification before finishing)

- Exactly 4 files changed (2 added, 2 updated).
- `.pipe/p11/P11_QA_REVIEW.md` matches the synthesis v2 final template and includes the R2 C*=FAIL‚ÜíMAJOR+ finding rule.
- `.pipe/p10/P10_AUTO_DIAGNOSE.md` matches synthesis v2 and includes the ‚Äúno internal timeout concept; orchestrator enforces budgets‚Äù rule.
- `CLAUDE.md` includes:
  - DECIDE row 13.5 for `qa_review`
  - `qa_review` action spec with explicit PASS/FAIL transitions and sequential counter wording (`old_total = ...`)
  - reflect Part A smart-skip gate logic that defers completion to `qa_review`
  - QA_REVIEW sentinel grammar docs (fixed block shape + rules)
  - P10 3-tier escalation policy + MISMATCH tooling repair queue docs
  - POLICY.yaml `qa_review:` documentation section
- `PROMPT_OPTIMIZATION.md` marks P11 implemented with a placeholder commit reference.
